# Importing necessary libraries
import numpy as np
from pymoo.problems.functional import FunctionalProblem
from pymoo.algorithms.moo.nsga2 import NSGA2
from pymoo.optimize import minimize
from src.utils.utils import generate_sir_dataset


# Genetic Algorithm class for S-I-R model
class MyNSGA2:
    '''
    A class to solve S-I-R model using Non-dominated Sorting Genetic Algorithm (NSGA-II).

    Methods
    -------
    find_optima(verbose=True):
        Finds the optimum value of beta and gamma.
    '''

    def __init__(self, data: np.ndarray, N: int, I0: int = 1) -> None:
        '''
        Constructs all the necessary attributes for the MyNSGA2 object.

        Parameters
        ----------
        data : ndarray
            The dataset as an array format.
        N : int
            Total population.
        I0 : int, optional
            Initial number of infected people.
        '''
        # Data
        self.__data = data
        self.__I_actual, self.__R_actual = self.__data[:, 1], self.__data[:, 2]

        # Problem Environment
        self.__N: int = N
        self.__I0: int = I0
        self.__num_of_days: int = self.__data.shape[0]

        # Problem Initializtion
        self.__bounds = np.array([[0, 0],
                                  [1, 1]])
        self.__problem = FunctionalProblem(n_var=2,
                                           objs=[self.__fitness_std_1,
                                                 self.__fitness_std_2],
                                           xl=self.__bounds[0],
                                           xu=self.__bounds[1])

        # Algorithm
        self.__algorithm = NSGA2(pop_size=200)

    # Evaluation Function 1
    def __fitness_std_1(self, params: list[float]) -> float:
        '''
        Finds the fitness_1 value of a solution.

        Parameters
        ----------
        params: list[float]
            Generated by the algorithm.

        Returns
        -------
        error: float
            Error/Fitness_1 value of the solution.
        '''
        beta, gamma = params

        pred_data = generate_sir_dataset(N=self.__N,
                                         I0=self.__I0,
                                         num_of_days=self.__num_of_days,
                                         beta=beta,
                                         gamma=gamma)

        I_pred = pred_data[:, 1]

        # Absolute Error of Standard Deviation
        error: float = np.abs(np.std(self.__I_actual) - np.std(I_pred))
        return error

    # Evaluation Function 2
    def __fitness_std_2(self, params: list[float]) -> float:
        '''
        Finds the fitness_2 value of a solution.

        Parameters
        ----------
        params: list[float]
            Generated by the algorithm.

        Returns
        -------
        error: float
            Error/Fitness_2 value of the solution.
        '''
        beta, gamma = params

        pred_data = generate_sir_dataset(N=self.__N,
                                         I0=self.__I0,
                                         num_of_days=self.__num_of_days,
                                         beta=beta,
                                         gamma=gamma)

        R_pred = pred_data[:, 2]

        # Absolute Error of Standard Deviation
        error: float = np.abs(np.std(self.__R_actual) - np.std(R_pred))
        return error

    # Call this function to get result
    def find_optima(self, verbose: bool = True) -> np.ndarray:
        '''
        Finds the optimum value of beta and gamma.

        Parameters
        ----------
        verbose: bool, optional
            Additional information per generation.

        Returns
        -------
        result: ndarray
            Resultant beta and gamma value.
        '''
        self.result = minimize(
            self.__problem, self.__algorithm, seed=1, verbose=verbose)

        return self.result.X
